# 数据结构与算法

## 什么是数据结构

数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。

*说明：以下数据结构和算法使用Scala语言实现数据结构的新增、删除、遍历*

### 数据的存储结构

#### 顺序存储

顺序表的特点是逻辑上相邻的数据元素，物理存储位置也相邻，并且，顺序表的存储空间需要预先分配。

**优点**：

- 方法简单，各种高级语言中都有数组，容易实现
- 不用为表示节点间的逻辑关系而增加额外的存储开销
- 顺序表具有按元素序号随机访问的特点

**缺点**：

- 在顺序表中做插入、删除操作时，平均移动表中的一半元素，因此对n较大的顺序表效率低
- 需要预先分配足够大的存储空间

#### 链式存储

在链表中逻辑上相邻的数据元素，物理存储位置不一定相邻，它使用指针实现元素之间的逻辑关系。并且，链表的存储空间是动态分配的。

**优点**：

- 插入、删除运算方便

**缺点**：

- 要占用额外的存储空间存储元素之间的关系，存储密度降低
- 链表不是一种随机存储结构，不能随机存取元素

### 数据的逻辑结构

1. **集合结构**
2. **线性结构**：常用的线性结构有：线性表，栈，队列，双队列，数组，串
3. **树形结构**：树形结构是一层次的嵌套结构。 一个树形结构的外层和内层有相似的结构， 所以这种结构多可以递归的表示。经典数据结构中的各种树状图是一种典型的树形结构：一颗树可以简单的表示为根， 左子树， 右子树。 左子树和右子树又有自己的子树
4. **图形结构**：图形结构，简称“图”，是一种复杂的数据结构。图形结构中，每个结点的前驱结点数和后续结点数可以任意多个

## 什么是算法

算法(Algorithm)是一系列解决问题的清晰指令，也就是说,能够对一定规范的输入，在有限时间内获得所要求的输出。

在现实世界里，算法就是解决问题的一个方案。

### 算法的特性

1.  **有穷性（Finiteness）**：算法的有穷性是指算法必须能在执行有限个步骤之后终止
2.  **确切性(Definiteness)**： 算法的每一步骤必须有确切的定义
3.  **输入项(Input)** ： 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件
4.  **输出项(Output)**：  一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的
5.  **可行性(Effectiveness)**： 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成

### 算法的基本要求

1.  **正确性**：算法至少应该具有输入、输出和加工处理无歧义性、能正确放映问题的需求、能够得到问题的正确答案
2.  **可读性**：便于阅读、理解和交流
3.  **健壮性**：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果
4.  **时间效率高和存储量低**：即算法执行的时间和算法执行的过程中需要的最大存储空间（算法程序运行时所占用的内存或外部硬盘存储空间 ）

### 算法的时间复杂度

（1）时间复杂度

​     时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。

​     常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)

​     时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1),

（2）空间复杂度

​    空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数

​    空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)

​    空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)

​                                 ax=N，则x=logaN，

​    空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).


## 数据结构

### 线性表

线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列。

#### 数组

数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。

```scala
//数组
```

#### 链表

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高。

链式线性表的基本分类：

- 单向链表
- 静态链表 -> 使用顺序结构实现链式线性表
- 双向链表 -> 每个节点除了数据元素，还包含一个指向上一个节点的指针和一个指向下一个节点的指针
- 循环链表 -> 线性表的尾部指向头节点，形成一个闭环

```scala
//链表
```

### 栈与队列

栈和队列也是比较常见的数据结构，它们是比较特殊的线性表，因为对于栈来说，访问、插入和删除元素只能在栈顶进行，对于队列来说，元素只能从队列尾插入，从队列头访问和删除。

栈和线性表的不同之处在于，栈只有进栈和出栈操作，并且遵循后进先出的规则，也就是说数据元素顺序进栈，逆序出栈，*类似弹匣*。

**栈**：限定在表尾进行插入和删除的线性表

```scala

```

**队列**：只允许在一端进行插入操作，而在另一端进行删除操作的线性表

```scala

```

### 树

树型结构是一类非常重要的非线性数据结构，其中以树和二叉树最为常用，森林（Forest）是m（m >= 0）棵互不相交的树的集合。

#### 术语总结

**节点深度**：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推
**节点高度**：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度
**树的深度**：一棵树中节点的最大深度就是树的深度，也称为高度
**父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点
**子节点**：一个节点含有的子树的根节点称为该节点的子节点
**节点的层次**：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推
**兄弟节点**：拥有共同父节点的节点互称为兄弟节点
**度**：节点的子树数目就是节点的度
**叶子节点**：度为零的节点就是叶子节点
**祖先**：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）
**后代**：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）
**森林**：m颗互不相交的树构成的集合就是森林

#### 二叉树

n（n>=0）个结点的有限集合，该集合或者为空集（空二叉树），或者为由一个根结点和最多两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

- 斜树：所有结点都只有左子树的二叉树叫左斜树，反之，叫右斜树。
- 满二叉树：所有结点都存在左右子树，并且所有叶结点都在同一层上。
- 完全二叉树：对一颗具有n个结点的二叉树按层编号，编号为i（1<=i<=n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置相同。
- 线索二叉树：指向前驱和后续的指针称为线索，加上线索的二叉树称为线索二叉树。

```scala
//斜树、满二叉树、完全二叉树、线索二叉树
```

#### 哈夫曼树（最优二叉树）

从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度就是从树根到每一结点的路径长度之和。其中，带权路径长度之和（WPL）最小的二叉树称作赫夫曼树。

```scala
//哈夫曼树
```

#### 平衡二叉树（AVL）

它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。

#### 二叉查找树（二叉搜索树）

#### 红黑树

#### B树

#### B+树

#### B*树

## 算法

### 查找算法

### 排序算法

